// ==UserScript==
// @name         Neon Panel Ultra v5.3 â€” Debugged & Stable
// @namespace    https://github.com/yourname/neon-panel-ultra
// @version      5.3
// @description  Conflict-safe, persistent, draggable Tampermonkey control: auto-refresh, random-refresh, keyword-stop, compact minimized button, themes, and hotkeys. Debugged drag/mini behavior and live theme updates.
// @match        *://*/*
// @grant        none
// @run-at       document-idle
// @license      MIT
// ==/UserScript==

(function () {
  "use strict";

  // ---------- STORAGE ----------
  const STORAGE_KEY = "ultraNeonPanel_v5_" + window.location.hostname;
  const saved = (() => {
    try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; } catch { return {}; }
  })();

  // defaults
  let state = {
    minimized: saved.minimized !== undefined ? saved.minimized : true,
    x: saved.x ?? null,
    y: saved.y ?? null,
    intervalMs: saved.intervalMs ?? 2000,
    randomMin: saved.randomMin ?? 1000,
    randomMax: saved.randomMax ?? 5000,
    useRandom: saved.useRandom ?? false,
    autoRefresh: saved.autoRefresh ?? false,
    theme: saved.theme ?? "#39ff14",
    keyword: saved.keyword ?? "",
    cacheBust: saved.cacheBust ?? true,
    sound: saved.sound ?? true,
  };

  function persist() {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (e) {}
  }

  // ---------- CONFLICT DETECTION ----------
  function detectConflictOnce() {
    try {
      if (document.querySelector('meta[http-equiv="refresh"]')) return {detected: true, reason: "meta-refresh"};
      const nav = performance.getEntriesByType("navigation")[0];
      if (nav && (nav.type === "reload" || nav.type === "back_forward")) return {detected: true, reason: `nav:${nav.type}`};
      // inline script heuristic
      const scripts = document.scripts || [];
      for (const s of scripts) {
        if (!s.src) {
          const t = (s.textContent || "").toLowerCase();
          if (t.includes("location.reload") || t.includes("location.replace") || t.includes("location.href") || t.includes("history.forward") || t.includes("history.back")) {
            return {detected: true, reason: "inline-navigation-script"};
          }
        }
      }
    } catch (e) {}
    return {detected: false, reason: null};
  }

  let conflict = detectConflictOnce();
  setInterval(() => { conflict = detectConflictOnce(); updateLED(); }, 1200);

  // ---------- UI BUILD ----------
  const panel = document.createElement("div");
  panel.id = "neonUltraPanel_v53";
  panel.innerHTML = `
    <div class="panel-wrap">
      <div class="header">
        <div id="led" class="led" title=""></div>
        <div class="title">âš¡ Neon Panel Ultra</div>
        <div class="hdr-actions">
          <button id="forceBtn" title="Force start (override conflict)">Force</button>
          <button id="minimizeBtn" title="Minimize/restore">_</button>
        </div>
      </div>

      <div class="controls">
        <button id="btnAuto">Start Auto</button>
        <button id="btnRandom">ðŸŽ² Random</button>
        <button id="btnNow">âŸ³ Now</button>
        <button id="btnBack">â¬…</button>
        <button id="btnFwd">âž¡</button>

        <label class="lbl">Interval <input id="inInterval" type="number" min="200" step="100"></label>
        <label class="lbl">Rand min <input id="inRandMin" type="number" min="200" step="100"></label>
        <label class="lbl">Rand max <input id="inRandMax" type="number" min="200" step="100"></label>

        <label class="lbl wide">Keyword <input id="inKeyword" type="text" placeholder="stop when appears"></label>
        <label class="lbl">Theme <input id="inColor" type="color"></label>
        <label class="lbl chk"><input id="inCache" type="checkbox">Cache-bust</label>
        <label class="lbl chk"><input id="inSound" type="checkbox">Sound</label>
      </div>

      <div class="status-row">
        <div class="progress"><div id="progBar"></div></div>
        <div class="status-text"><span id="stText">idle</span> â€¢ <span id="stCount">0</span></div>
      </div>
    </div>
  `;
  document.body.appendChild(panel);

  // mini button (tiny glowing circle)
  const miniBtn = document.createElement("div");
  miniBtn.id = "neonUltraMini_v53";
  miniBtn.title = "âš¡ Neon Panel Ultra (click to open)";
  document.body.appendChild(miniBtn);

  // ---------- STYLES ----------
  const css = `
  #neonUltraPanel_v53, #neonUltraMini_v53 { z-index:2147483647; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; }
  #neonUltraPanel_v53 { position: fixed; right: 20px; bottom: 20px; min-width: 320px; background: rgba(0,0,0,0.6); border-radius:12px; padding:10px; border:2px solid ${state.theme}; box-shadow:0 0 18px ${state.theme}, 0 0 36px ${state.theme}; color:${state.theme}; backdrop-filter: blur(4px); cursor: grab; user-select:none; }
  #neonUltraPanel_v53.moving { transition: none !important; }
  #neonUltraPanel_v53 .header { display:flex; align-items:center; gap:8px; }
  #neonUltraPanel_v53 .led { width:12px; height:12px; border-radius:50%; background:${conflict.detected ? '#ff3b3b' : state.theme}; box-shadow: 0 0 10px ${conflict.detected ? '#ff3b3b' : state.theme}; border:1px solid rgba(255,255,255,0.06); }
  #neonUltraPanel_v53 .title { font-weight:800; flex:1; color:var(--theme); text-shadow:0 0 8px var(--theme); }
  #neonUltraPanel_v53 .hdr-actions button { margin-left:6px; padding:4px 8px; border-radius:6px; border:none; background:var(--theme); color:#000; font-weight:800; cursor:pointer; box-shadow:0 0 8px var(--theme); }
  #neonUltraPanel_v53 .controls { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; align-items:center; }
  #neonUltraPanel_v53 .controls button { padding:6px 10px; border-radius:8px; border:none; cursor:pointer; background:var(--theme); color:#000; font-weight:800; box-shadow:0 0 8px var(--theme); }
  #neonUltraPanel_v53 .controls .lbl { display:flex; align-items:center; gap:6px; color:var(--theme); font-weight:800; }
  #neonUltraPanel_v53 .controls input[type="number"], #neonUltraPanel_v53 input[type="text"] { background:#000; color:var(--theme); border:2px solid var(--theme); padding:4px 6px; border-radius:6px; font-weight:700; width:90px; }
  #neonUltraPanel_v53 .controls input[type="color"] { width:36px; height:30px; border-radius:6px; padding:0; border:none; cursor:pointer; box-shadow:0 0 8px var(--theme); }
  #neonUltraPanel_v53 .controls .wide input[type="text"] { width:180px; }
  #neonUltraPanel_v53 .controls .chk input { width:14px; height:14px; }
  #neonUltraPanel_v53 .status-row { display:flex; gap:8px; align-items:center; margin-top:8px; }
  #neonUltraPanel_v53 .progress { flex:1; height:8px; background: rgba(255,255,255,0.06); border-radius:999px; overflow:hidden; border:1px solid var(--theme); }
  #neonUltraPanel_v53 #progBar { width:0%; height:100%; background:var(--theme); transition: width .1s linear; box-shadow:0 0 8px var(--theme); }
  #neonUltraPanel_v53 .status-text { font-weight:800; color:var(--theme); min-width:120px; text-align:right; }
  #neonUltraMini_v53 { position: fixed; width:34px; height:34px; border-radius:50%; background: ${state.theme}; box-shadow:0 0 20px ${state.theme}, 0 0 40px ${state.theme}; right:20px; bottom:20px; cursor:pointer; display:none; z-index:2147483648; }
  #neonUltraMini_v53:hover { transform: scale(1.12); box-shadow:0 0 28px ${state.theme}, 0 0 52px ${state.theme}; }
  @media (max-width:520px){ #neonUltraPanel_v53 { min-width:90vw; } }
  `;
  const style = document.createElement("style");
  style.textContent = css;
  document.head.appendChild(style);

  // set CSS theme variable
  function applyThemeColor(color) {
    panel.style.setProperty("--theme", color);
    // update static inline elements too
    const leds = panel.querySelectorAll(".led");
    leds.forEach(l => l.style.background = conflict.detected ? "#ff3b3b" : color);
    panel.style.borderColor = color;
    panel.style.boxShadow = `0 0 18px ${color}, 0 0 36px ${color}`;
    const btns = panel.querySelectorAll(".controls button, .hdr-actions button");
    btns.forEach(b => { b.style.background = color; b.style.boxShadow = `0 0 8px ${color}`; });
    miniBtn.style.background = color;
    miniBtn.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}`;
  }
  applyThemeColor(state.theme);

  // ---------- ELEMENT REFS ----------
  const ledEl = panel.querySelector("#led");
  const btnAuto = panel.querySelector("#btnAuto");
  const btnRandom = panel.querySelector("#btnRandom");
  const btnNow = panel.querySelector("#btnNow");
  const btnBack = panel.querySelector("#btnBack");
  const btnFwd = panel.querySelector("#btnFwd");
  const inInterval = panel.querySelector("#inInterval");
  const inRandMin = panel.querySelector("#inRandMin");
  const inRandMax = panel.querySelector("#inRandMax");
  const inKeyword = panel.querySelector("#inKeyword");
  const inColor = panel.querySelector("#inColor");
  const inCache = panel.querySelector("#inCache");
  const inSound = panel.querySelector("#inSound");
  const btnMin = panel.querySelector("#minimizeBtn");
  const btnForce = panel.querySelector("#forceBtn");
  const progBar = panel.querySelector("#progBar");
  const stText = panel.querySelector("#stText");
  const stCount = panel.querySelector("#stCount");

  // initialize inputs
  inInterval.value = state.intervalMs;
  inRandMin.value = state.randomMin;
  inRandMax.value = state.randomMax;
  inKeyword.value = state.keyword;
  inColor.value = state.theme;
  inCache.checked = !!state.cacheBust;
  inSound.checked = !!state.sound;
  btnAuto.textContent = state.autoRefresh ? "Stop Auto" : "Start Auto";
  btnRandom.textContent = state.useRandom ? "Stop Random" : "ðŸŽ² Random";

  // ---------- REFRESH LOGIC ----------
  let runner = null;
  let refreshCounter = 0;
  let nextDue = null;
  let progressTick = null;

  function beep() {
    if (!state.sound) return;
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "sine"; o.frequency.value = 880;
      o.connect(g); g.connect(ctx.destination);
      const now = ctx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.18, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
      o.start(now); o.stop(now + 0.14);
      setTimeout(()=>ctx.close(), 250);
    } catch(e){}
  }

  function cacheReload() {
    if (!state.cacheBust) { location.reload(); return; }
    try {
      const u = new URL(location.href);
      u.searchParams.set("_nu", Date.now().toString());
      location.replace(u.toString());
    } catch {
      location.reload();
    }
  }

  function meetsKeyword() {
    if (!state.keyword || !state.keyword.trim()) return false;
    try { return document.body && document.body.innerText.toLowerCase().includes(state.keyword.toLowerCase()); } catch { return false; }
  }

  function shouldStopByLimits(startTime) {
    // placeholder for maxCount / maxMinutes if you want to expand; currently not used but safe hook
    return false;
  }

  function clearRunner() {
    if (runner) { clearTimeout(runner); runner = null; }
    if (progressTick) { clearInterval(progressTick); progressTick = null; }
    nextDue = null;
    progBar.style.width = "0%";
    stText.textContent = "idle";
  }

  function scheduleNext(ms) {
    clearRunner();
    if (ms <= 0) { ms = 1000; }
    nextDue = Date.now() + ms;
    const start = Date.now();
    progBar.style.width = "0%";
    progressTick = setInterval(() => {
      const rem = Math.max(0, nextDue - Date.now());
      const pct = Math.max(0, Math.min(1, 1 - rem / ms));
      progBar.style.width = (pct * 100) + "%";
      stText.textContent = `next ~${Math.ceil(rem/1000)}s`;
    }, 120);

    runner = setTimeout(() => {
      clearRunner();
      refreshCounter++;
      stCount.textContent = String(refreshCounter);
      if (meetsKeyword()) {
        // found keyword -> stop everything
        stopAll();
        return;
      }
      beep();
      cacheReload();
    }, ms);
  }

  function startAuto() {
    stopRandom();
    if (conflict.detected) {
      // do not auto-start when conflict: leave user to manually force
      stText.textContent = "blocked by external refresh";
      return;
    }
    state.autoRefresh = true; persist();
    btnAuto.textContent = "Stop Auto";
    scheduleNext(Math.max(200, parseInt(state.intervalMs,10) || 1000));
  }

  function stopAuto() {
    state.autoRefresh = false; persist();
    btnAuto.textContent = "Start Auto";
    clearRunner();
  }

  function startRandom() {
    stopAuto();
    if (conflict.detected) {
      stText.textContent = "blocked by external refresh";
      return;
    }
    state.useRandom = true; persist();
    btnRandom.textContent = "Stop Random";
    // compute random interval and schedule tick chain
    const loop = () => {
      const min = Math.max(200, parseInt(state.randomMin,10) || 1000);
      const max = Math.max(min, parseInt(state.randomMax,10) || (min*2));
      const ms = Math.floor(Math.random() * (max - min + 1)) + min;
      scheduleNext(ms);
      // after runner fires the page will reload; this loop will be started after reload if state.useRandom remains true
    };
    loop();
  }

  function stopRandom() {
    state.useRandom = false; persist();
    btnRandom.textContent = "ðŸŽ² Random";
    clearRunner();
  }

  function stopAll() {
    state.autoRefresh = false;
    state.useRandom = false;
    persist();
    btnAuto.textContent = "Start Auto";
    btnRandom.textContent = "ðŸŽ² Random";
    clearRunner();
  }

  // manual
  btnNow.addEventListener("click", () => { beep(); cacheReload(); });

  btnBack.addEventListener("click", () => { if (history.length > 1) history.back(); else alert("No previous page"); });
  btnFwd.addEventListener("click", () => { history.forward(); });

  // control buttons
  btnAuto.addEventListener("click", () => {
    if (state.autoRefresh) stopAuto();
    else startAuto();
  });

  btnRandom.addEventListener("click", () => {
    if (state.useRandom) stopRandom();
    else startRandom();
  });

  btnForce.addEventListener("click", () => {
    // force start override: start whichever was last chosen, or start auto
    if (state.useRandom) startRandom();
    else startAuto();
  });

  // inputs
  inInterval.addEventListener("change", (e) => {
    const v = Math.max(200, parseInt(e.target.value,10) || 200);
    state.intervalMs = v; persist();
    if (state.autoRefresh) startAuto();
  });
  inRandMin.addEventListener("change", (e) => { state.randomMin = Math.max(200, parseInt(e.target.value,10) || 200); persist(); });
  inRandMax.addEventListener("change", (e) => { state.randomMax = Math.max(200, parseInt(e.target.value,10) || 200); persist(); });
  inKeyword.addEventListener("change", (e) => { state.keyword = e.target.value || ""; persist(); });
  inColor.addEventListener("input", (e) => {
    state.theme = e.target.value; persist();
    applyThemeColor(state.theme);
  });
  inCache.addEventListener("change", (e) => { state.cacheBust = !!e.target.checked; persist(); });
  inSound.addEventListener("change", (e) => { state.sound = !!e.target.checked; persist(); });

  // ---------- MINIMIZE / MINI BUTTON ----------
  function showMini() {
    panel.style.display = "none";
    miniBtn.style.display = "block";
  }
  function hideMini() {
    panel.style.display = "block";
    miniBtn.style.display = "none";
  }

  // toggle by btnMin or miniBtn click
  btnMin.addEventListener("click", () => {
    state.minimized = true; persist();
    showMini();
  });
  miniBtn.addEventListener("click", () => {
    state.minimized = false; persist();
    hideMini();
  });

  // restore initial visibility & position
  (function restorePlacement() {
    // position
    if (state.x !== null && state.y !== null) {
      panel.style.left = state.x + "px"; panel.style.top = state.y + "px";
      panel.style.right = "auto"; panel.style.bottom = "auto"; panel.style.position = "fixed";
      miniBtn.style.left = state.x + "px"; miniBtn.style.top = state.y + "px";
      miniBtn.style.right = "auto"; miniBtn.style.bottom = "auto"; miniBtn.style.position = "fixed";
    } else {
      // default anchored bottom-right
      panel.style.right = "20px"; panel.style.bottom = "20px";
      miniBtn.style.right = "20px"; miniBtn.style.bottom = "20px";
    }

    if (state.minimized) showMini(); else hideMini();
  })();

  // ---------- DRAGGING (full panel) with movement threshold ----------
  let dragging = false, dragStartX = 0, dragStartY = 0, moved = false;
  const DRAG_THRESHOLD = 6;

  panel.addEventListener("mousedown", (ev) => {
    const tag = (ev.target && ev.target.tagName) ? ev.target.tagName.toUpperCase() : "";
    // don't start drag when interacting with controls
    if (["INPUT","BUTTON","SELECT","LABEL","TEXTAREA"].includes(tag)) return;
    dragging = true;
    moved = false;
    dragStartX = ev.clientX - (panel.getBoundingClientRect().left || 0);
    dragStartY = ev.clientY - (panel.getBoundingClientRect().top || 0);
    panel.classList.add("moving");
    ev.preventDefault();
  });

  document.addEventListener("mousemove", (ev) => {
    if (!dragging) return;
    const left = Math.max(4, Math.min(window.innerWidth - panel.offsetWidth - 4, ev.clientX - dragStartX));
    const top  = Math.max(4, Math.min(window.innerHeight - panel.offsetHeight - 4, ev.clientY - dragStartY));
    if (!moved && (Math.abs(ev.clientX - (dragStartX + panel.getBoundingClientRect().left)) > DRAG_THRESHOLD || Math.abs(ev.clientY - (dragStartY + panel.getBoundingClientRect().top)) > DRAG_THRESHOLD)) {
      moved = true;
    }
    panel.style.left = left + "px"; panel.style.top = top + "px"; panel.style.right = "auto"; panel.style.bottom = "auto"; panel.style.position = "fixed";
    // keep miniBtn in sync (so when switching to mini the position matches)
    miniBtn.style.left = panel.style.left; miniBtn.style.top = panel.style.top; miniBtn.style.right = "auto"; miniBtn.style.bottom = "auto";
  });

  document.addEventListener("mouseup", () => {
    if (!dragging) return;
    dragging = false;
    panel.classList.remove("moving");
    if (moved) {
      // save new position
      state.x = panel.getBoundingClientRect().left;
      state.y = panel.getBoundingClientRect().top;
      persist();
    }
  });

  // ---------- DRAGGING (mini button) ----------
  let miniDragging = false, miniOffX=0, miniOffY=0, miniMoved=false;
  miniBtn.addEventListener("mousedown", (ev) => {
    miniDragging = true;
    miniMoved = false;
    miniOffX = ev.clientX - miniBtn.getBoundingClientRect().left;
    miniOffY = ev.clientY - miniBtn.getBoundingClientRect().top;
    ev.preventDefault();
  });

  document.addEventListener("mousemove", (ev) => {
    if (!miniDragging) return;
    const left = Math.max(4, Math.min(window.innerWidth - miniBtn.offsetWidth - 4, ev.clientX - miniOffX));
    const top  = Math.max(4, Math.min(window.innerHeight - miniBtn.offsetHeight - 4, ev.clientY - miniOffY));
    if (!miniMoved && (Math.abs(ev.clientX - (miniOffX + miniBtn.getBoundingClientRect().left)) > DRAG_THRESHOLD || Math.abs(ev.clientY - (miniOffY + miniBtn.getBoundingClientRect().top)) > DRAG_THRESHOLD)) {
      miniMoved = true;
    }
    miniBtn.style.left = left + "px"; miniBtn.style.top = top + "px"; miniBtn.style.right = "auto"; miniBtn.style.bottom = "auto"; miniBtn.style.position = "fixed";
    // keep full panel in sync
    panel.style.left = miniBtn.style.left; panel.style.top = miniBtn.style.top;
  });

  document.addEventListener("mouseup", () => {
    if (!miniDragging) return;
    miniDragging = false;
    if (miniMoved) {
      state.x = miniBtn.getBoundingClientRect().left;
      state.y = miniBtn.getBoundingClientRect().top;
      persist();
    }
  });

  // ---------- LED update ----------
  function updateLED() {
    if (conflict.detected) {
      ledEl.style.background = "#ff3b3b";
      ledEl.style.boxShadow = "0 0 10px #ff3b3b";
      ledEl.title = `External navigation detected: ${conflict.reason || "unknown"}. Auto-start disabled.`;
    } else {
      ledEl.style.background = state.theme;
      ledEl.style.boxShadow = `0 0 10px ${state.theme}`;
      ledEl.title = "No external navigation detected â€” auto-start allowed.";
    }
  }
  updateLED();

  // ---------- HOTKEYS ----------
  document.addEventListener("keydown", (e) => {
    if (!e.ctrlKey || !e.altKey) return;
    const k = (e.key || "").toLowerCase();
    if (k === "r") { e.preventDefault(); if (state.autoRefresh) stopAuto(); else startAuto(); }
    if (k === "n") { e.preventDefault(); btnNow.click(); }
    if (k === "m") { e.preventDefault(); if (state.minimized) { miniBtn.click(); } else { btnMin.click(); } }
    if (k === "x") { e.preventDefault(); stopAll(); }
  });

  // ---------- STARTUP BEHAVIOR ----------
  // ensure UI shows current state
  function reflectUI() {
    inInterval.value = state.intervalMs;
    inRandMin.value = state.randomMin;
    inRandMax.value = state.randomMax;
    inKeyword.value = state.keyword;
    inColor.value = state.theme;
    inCache.checked = !!state.cacheBust;
    inSound.checked = !!state.sound;
    btnAuto.textContent = state.autoRefresh ? "Stop Auto" : "Start Auto";
    btnRandom.textContent = state.useRandom ? "Stop Random" : "ðŸŽ² Random";
    applyThemeColor(state.theme);
  }
  reflectUI();

  // Do not auto-start if conflict detected; otherwise resume last mode
  if (!conflict.detected) {
    if (state.useRandom) startRandom();
    else if (state.autoRefresh) startAuto();
  } else {
    // if there was a saved enabled state but conflict exists, keep system stopped
    stText.textContent = "blocked by external refresh";
  }

  // expose debug helper
  try { window.__neonUltra_v53 = { state, persist, detectConflictOnce }; } catch(e) {}

  // save periodically as well (in case of abrupt unload)
  setInterval(persist, 3000);

})();
